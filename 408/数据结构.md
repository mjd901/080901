# 数据结构

**算法 + 数据结构 = 程序。**

## 基础知识

### 数据的概念

数据：即信息的载体，是对客观事物的符号表示，指能输入到计算机中并被计算机程序处理的符号的总称。整数，实数，字符，文字，声音，图形，图像等都是数据。

数据元素：**是数据的基本单位**，一般由一个或多个数据项组成。数据项是不可分割的、含有独立意义的最小数据单位。

数据项：数据元素中的**单个字段或属性**。 

数据结构：是反映数据元素之间存在一种或多种特定关系的数据元素的集合的表示，即带有结构的数据元素的集合。

数据类型：值的集合和定义在**集合上**的一组**操作的总称**。

原子类型：**值不可再分**的数据类型，如布尔类型、int类型。

结构类型：值可以再分解成若干个分量的数据类型，如结构体。

抽象数据类型：抽象数据组织和与之相关的操作。定义抽象数据类型时，**不关心具体存储结构，只关心逻辑结构和数据运算**。



### 数据结构三要素

#### 逻辑结构

逻辑结构分类：集合、线性结构、树形结构、图状结构。



#### 物理结构

物理结构分类：顺序存储、链式存储、索引存储、散列存储。

顺序存储：数据元素在物理上必须是**连续的**。

非顺序存储：数据元素在物理上必须是**离散的**。



#### 数据运算

根据数据的逻辑结构定义需要的运算，不同存储结构下，数据运算的实现方式不同。



### 算法

算法是对特定问题求解步骤的一种描述，是用来解决某个问题的一些指令的集合。它是指令的有限序列，其中每条指令表示一个或多个操作。算法的特性：**有穷性、确定性、可行性、输入和输出**。评价算法优劣标准：**正确性、可读性、健壮性、高效率与低存储量需求**。

**时间复杂度：度量算法执行时间的多少。** 

简化时间复杂度表达式：忽略低阶部分和常数项。多项相加时只保留最高阶的项，相乘时合并为一项。

![image-20241027193414518](https://raw.githubusercontent.com/qinshuxiang/repo/main/算法的时间复杂度.png)

$O(1) \rightarrow O(\log_2 n) \rightarrow O(n) \rightarrow O(n \log_2 n) \rightarrow O(n^2) \rightarrow O(n^3) \rightarrow O(2^n) \rightarrow O(n!)$

**空间复杂度：度量算法执行过程中的内存开销。**

算法执行时，需要内存存放局部变量和参数。执行过程中所需的内存空间大小是固定不变的常数值。

如果算法所需的内存空间与问题规模n无关，则称该算法可以原地工作。

函数递归调用会导致内存开销的增加，一般递归调用的空间复杂度为O(n)。



## 线性表

线性表是由相同数据类型的n个数据元素组成的有限序列，数据元素之间有线性关系，每个元素有唯一的位序。

**线性表有一个开始节点和一个结束节点，其余的内部节点有且仅有一个直接前驱和一个直接后继。**

线性表的顺序存储结构：数组，数组的存储空间是连续的，元素在存储空间按照逻辑顺序依次存放。

线性表的链式存储结构：链表，有单链表，循环链表，双向链表、静态链表。



## 栈、队列、数组

**栈的进出原则，先进后出**

**队列栈的进出原则，先进先出**



## 串

串（字符串）是由字符组成的有限序列，每个字符串都有一个名字（串名），以及字符的数量（串长度）。



## 树与二叉树

二叉树是一种特殊的树形数据结构，每个节点最多只能有两个子节点（通常称为左子节点和右子节点）。

1. 二叉树第 i 层上至多含有 `2^(i - 1)`个节点。
2. 深度为 k 的二叉树至多含有`2^k - 1 `个节点
3. 对于任意一棵二叉树，度为0的节点比度为2的节点多一个。`n_0 = n_2 + 1`

**完全二叉树**：除了最底层外，每一层都被完全填满，并且最底层的节点尽量向左对齐。

**满二叉树**：满二叉树的每一层都被完全填满。

``` javascript
// 完全二叉树
       1
      / \
     2   3
    / \ 
   4  5

// 满二叉树
       1
      / \
     2   3
    / \ / \
   4  5 6  7
```

**遍历方式**：二叉树的遍历方式有：

- **前**序遍历（**根**->左->右）
- **中**序遍历（左->**根**->右）
- **后**序遍历（左->右->**根**）
- 层序遍历（按层访问）



## 图



## 查找

线性表

顺序查找

二分查找，如果中间项 `mid = left + (right - left) // 2` 向下取整

```javascript
3 6 8 10 12 15 16 18 21 25 30 查找 11
11 < 15
11 > 8
11 > 10 // mid 向下取整
11 < 12
// 11 不存在
```



## 排序

直接插入排序

```javascript
10 1 9 2 8 4排序
1 10
1 9 10
1 2 9 10
1 2 8 9 10
1 2 4 8 9 10
```

希尔排序：选择一个初始间隔 `gap`（一般为数组长度的一半），将数组按间隔分组。对每组使用**插入排序**进行排序。减小间隔，重复步骤2，直到间隔为1。最后进行一次标准的插入排序。

冒泡排序：逐步将最大或最小的元素**冒泡**到一端，遍历数组，相邻元素比较，如果顺序错误就交换，对未排序部分重复上述步骤，直到数组有序。

快速排序：使用分治法，通过选定一个基准元素（pivot）将数组分为两部分递归排序，继续对左右子数组递归执行快速排序。

选择排序：遍历数组找到最小元素，与第一个元素交换，从剩余部分中找到最小元素，与第二个元素交换

归并排序：将数组递归拆分成两个子数组，直到每个子数组只剩一个元素。合并两个有序子数组时，按大小顺序放回原数组。重复直到所有子数组合并完成。







